
# sharding-jdbc 分片规则，该配置文件只进行了一个数据库水平分表的配置

#定义数据源（有多个数据源，以逗号分隔，在配置每个数据源的配置）
# “m1”为自定义名称，需要和下面的数据源的配置对应
sharding.jdbc.datasource.names = m1,m2

sharding.jdbc.datasource.m1.type = com.alibaba.druid.pool.DruidDataSource
sharding.jdbc.datasource.m1.driverClassName = com.mysql.cj.jdbc.Driver
sharding.jdbc.datasource.m1.url = jdbc:mysql://localhost:3306/order_db_1?serverTimezone=GMT&autoReconnect=true&failOverReadOnly=false&verifyServerCertificate=false
sharding.jdbc.datasource.m1.username = root
sharding.jdbc.datasource.m1.password = root

sharding.jdbc.datasource.m2.type = com.alibaba.druid.pool.DruidDataSource
sharding.jdbc.datasource.m2.driverClassName = com.mysql.cj.jdbc.Driver
sharding.jdbc.datasource.m2.url = jdbc:mysql://localhost:3306/order_db_2?serverTimezone=GMT&autoReconnect=true&failOverReadOnly=false&verifyServerCertificate=false
sharding.jdbc.datasource.m2.username = root
sharding.jdbc.datasource.m2.password = root


# 指定t_order表的数据分布情况，配置数据节点
#   此处的tables.t_order中的（t_order）为自定义名称，它和我们在程序中写的sql语句中的表名要对应起来，假如我们这叫abc,那么当我们写sql语句要操作该表时也应该写abc
#  （和数据库中真实名称无关，因为sharding-jdbc会帮我们处理sql语句）      该表达式表示有实际有t_order_1,t_order_2两张表，通过拼接后面的1，2来确定
sharding.jdbc.config.sharding.tables.t_order.actual-data-nodes= m$->{1..2}.t_order_$->{1..2}

#指定t_order表的主键生成策略为SNOWFLAKE （默认采用的是雪花算法，全局唯一自增的Id）
sharding.jdbc.config.sharding.tables.t_order.key-generator-column-name=order_id
#http://shardingsphere.apache.org/document/legacy/2.x/cn/02-guide/key-generator/
# **不要指定默认的算法，否则会报错**
#sharding.jdbc.config.sharding.tables.t_order.key-generator-class-name= io.shardingjdbc.core.keygen.DefaultKeyGenerator

## 指定t_order表的分库策略,这里使用user_id作为分片键
sharding.jdbc.config.sharding.tables.t_order.database-strategy.inline.sharding-column= user_id
sharding.jdbc.config.sharding.tables.t_order.database-strategy.inline.algorithm-expression= m$->{user_id % 2 + 1}

## 指定t_order表的分片策略，分片策略包括分片键（以那个字段进行分片操作）和分片算法（通过这个算法来确定用那个表来操作该数据）
# 以order_id的值来分片
sharding.jdbc.config.sharding.tables.t_order.table-strategy.inline.sharding-column= order_id
# 通过order_id除2取余加1来确定使用那张表
sharding.jdbc.config.sharding.tables.t_order.table-strategy.inline.algorithm-expression= t_order_$->{order_id % 2 + 1}

# 打开sql输出日志
sharding.jdbc.config.props.sql.show = true

#mybatis的驼峰命名
mybatis.configuration.map-underscore-to-camel-case=true

logging.level.root = info
logging.level.org.springframework.web = info
logging.level.cn.pengan.simple-demo = debug
logging.level.druid.sql = debug

